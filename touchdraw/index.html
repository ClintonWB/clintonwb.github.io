<!DOCTYPE html>
<html>
<head>
    <title>Touchdraw Pad</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #app-container {
            width: 100vw;
            height: 100vh;
            background-color: black;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #myCanvas {
            display: block;
            background-color: black;
            cursor: crosshair;
            flex-grow: 1;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        button {
            padding: 10px 18px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #333;
            color: white;
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        button:hover {
            background-color: #444;
            transform: translateY(-1px);
        }

        #clearButton { background-color: #EE4E34; }
        #clearButton:hover { background-color: #d63d25; }
        
        #saveButton { background-color: #2BAE66; }
        #saveButton:hover { background-color: #218c52; }

        #fsbutton { background-color: #4831D4; }

        /* HIDE Clear and Save buttons when in Full Screen mode */
        #app-container:fullscreen #saveButton {
            display: none;
        }

        .hint {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #555;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }
        
        #app-container:fullscreen .hint {
            display: none;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div class="controls">
            <button id="saveButton">Save Drawing</button>
            <button id="clearButton">Clear Drawing</button>
            <button id="fsbutton">Full Screen</button>
        </div>

        <div class="hint">Draw with mouse/touch or press ANY key for a random shape!</div>

        <canvas id="myCanvas"></canvas>
    </div>
    
    <a id="link" style="display:none"></a>

    <script type="text/javascript">
        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        
        function debounce(callback, delay) {
            let timer
            return function() {
                clearTimeout(timer)
                timer = setTimeout(() => {
                callback();
                }, delay)
            }
        }

        function getBoundingBox(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = new Uint32Array(imageData.data.buffer); // Treat 4 bytes as 1 unit

            let minY = 0, maxY = height - 1, minX = 0, maxX = width - 1;

            // 1. Find Top (Scan rows top-to-bottom)
            while (minY < height && !rowHasPixels(data, minY, width)) minY++;
            if (minY === height) return null; // Canvas is empty

            // 2. Find Bottom (Scan rows bottom-to-top)
            while (maxY > minY && !rowHasPixels(data, maxY, width)) maxY--;

            // 3. Find Left (Scan columns left-to-right, only between minY and maxY)
            while (minX < width && !colHasPixels(data, minX, minY, maxY, width)) minX++;

            // 4. Find Right (Scan columns right-to-left, only between minY and maxY)
            while (maxX > minX && !colHasPixels(data, maxX, minY, maxY, width)) maxX--;

            return {
                x: minX,
                y: minY,
                w: maxX - minX + 1,
                h: maxY - minY + 1
            };
        }

        // Helper: Check if a specific row contains any non-zero pixels
        function rowHasPixels(data, y, width) {
            const start = y * width;
            for (let x = 0; x < width; x++) {
                if (data[start + x] !== 0) return true;
            }
            return false;
        }

        // Helper: Check if a specific column contains any non-zero pixels
        function colHasPixels(data, x, minY, maxY, width) {
            for (let y = minY; y <= maxY; y++) {
                if (data[y * width + x] !== 0) return true;
            }
            return false;
        }

        function resize(ctx, canvas) {
            const padding = 40; 
            const box = getBoundingBox(ctx, canvas.width, canvas.height);

            const winW = window.innerWidth;
            const winH = window.innerHeight;

            if (!box) {
                canvas.width = winW;
                canvas.height = winH;
                return;
            }

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = box.w;
            tempCanvas.height = box.h;
            tempCanvas.getContext('2d').putImageData(
                ctx.getImageData(box.x, box.y, box.w, box.h), 0, 0
            );

            canvas.width = winW;
            canvas.height = winH;

            const availableW = winW - (padding * 2);
            const availableH = winH - (padding * 2);
            const scale = Math.min(1, availableW / box.w, availableH / box.h);
            
            const finalW = box.w * scale;
            const finalH = box.h * scale;

            const offsetX = (winW - finalW) / 2;
            const offsetY = (winH - finalH) / 2;

            ctx.drawImage(tempCanvas, 0, 0, box.w, box.h, offsetX, offsetY, finalW, finalH);
        }

        window.addEventListener("load", () => {
            const container = document.getElementById("app-container");
            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");
            
            window.addEventListener('resize', debounce(resize.bind(this,canvas,ctx), 250));
            resize(canvas, ctx);

            let lineWidth = 3;
            let currentTouches = [];
            let isMouseDown = false;

            const randomColor = () => {
                const colors = ["#00A3EE", "#F5D908", "#D80351", "#EE4E34", "#FF69B4", "#990011", "#4831D4", "#FEE715", "#00539C", "#2BAE66", "#BF40BF"];
                return colors[Math.floor(Math.random() * colors.length)];
            };

            const clearCanvas = () => ctx.clearRect(0, 0, canvas.width, canvas.height);

            const saveCanvas = () => {
                const link = document.getElementById("link");
                link.setAttribute("download", `Drawing-${Date.now()}.png`);
                link.setAttribute("href", canvas.toDataURL("image/png"));
                link.click();
            };

            const findCurrentTouchIndex = (id) => currentTouches.findIndex(t => t.id === id);

            // --- DRAWING LOGIC ---
            const startDrawing = (id, x, y) => {
                const color = randomColor();
                currentTouches.push({ id, pageX: x, pageY: y, color });
                ctx.beginPath();
                ctx.arc(x, y, lineWidth / 2, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            };

            const moveDrawing = (id, x, y) => {
                const idx = findCurrentTouchIndex(id);
                if (idx >= 0) {
                    const t = currentTouches[idx];
                    ctx.beginPath();
                    ctx.moveTo(t.pageX, t.pageY);
                    ctx.lineTo(x, y);
                    ctx.lineWidth = lineWidth;
                    ctx.strokeStyle = t.color;
                    ctx.lineCap = "round";
                    ctx.stroke();
                    t.pageX = x; t.pageY = y;
                }
            };

            const stopDrawing = (id) => {
                const idx = findCurrentTouchIndex(id);
                if (idx >= 0) currentTouches.splice(idx, 1);
            };

            // Event Bindings
            canvas.addEventListener("mousedown", (e) => {
                isMouseDown = true;
                startDrawing("mouse", e.clientX, e.clientY);
            });
            window.addEventListener("mousemove", (e) => {
                if (isMouseDown) moveDrawing("mouse", e.clientX, e.clientY);
            });
            window.addEventListener("mouseup", () => {
                isMouseDown = false;
                stopDrawing("mouse");
            });

            canvas.addEventListener("touchstart", (e) => {
                e.preventDefault();
                [...e.changedTouches].forEach(t => startDrawing(t.identifier, t.pageX, t.pageY));
            });
            canvas.addEventListener("touchmove", (e) => {
                e.preventDefault();
                [...e.changedTouches].forEach(t => moveDrawing(t.identifier, t.pageX, t.pageY));
            });
            canvas.addEventListener("touchend", (e) => {
                [...e.changedTouches].forEach(t => stopDrawing(t.identifier));
            });

            // Button Listeners
            document.getElementById("clearButton").addEventListener("click", function(e){
                clearCanvas();
                this.blur();
            });
            document.getElementById("saveButton").addEventListener("click", function(e){
                saveCanvas();
                this.blur();
            });
            document.getElementById("fsbutton").addEventListener("click", function(e){
                if (!document.fullscreenElement) {
                    container.requestFullscreen();
                    document.getElementById("fsbutton").innerText = "Exit Full Screen";
                } else {
                    document.exitFullscreen();
                    document.getElementById("fsbutton").innerText = "Full Screen";
                }
                this.blur();
            });

            // Keyboard Shortcuts
            document.addEventListener("keydown", (event) => {
                if (event.repeat) return;
                if (event.code === "Space" || event.code === "Enter") {
                    event.preventDefault();
                }

                if (event.code === "KeyF" && !document.fullscreenElement) {
                    container.requestFullscreen();
                } else {
                    drawRandomShape(event.code);
                }
            });

            function drawRandomShape(code) {
                const shapeButtons = ["KeyS", "KeyH", "KeyU", "KeyL", "KeyN", "KeyT"];
                const finalCode = shapeButtons.includes(code) ? code : shapeButtons[Math.floor(Math.random() * shapeButtons.length)];

                const x = Math.floor(Math.random() * (canvas.width - 100)) + 50;
                const y = Math.floor(Math.random() * (canvas.height - 100)) + 50;
                const angle = Math.random() * Math.PI * 2;
                const scale = Math.random() * 2.5 + 0.5;

                const fillColor = randomColor();
                const strokeColor = randomColor();

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.scale(scale, scale);
                
                ctx.fillStyle = fillColor;
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 4 / scale;

                ctx.beginPath();
                switch (finalCode) {
                    case "KeyS":
                        ctx.arc(75, 75, 50, 0, Math.PI * 2, true);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(110, 75);
                        ctx.arc(75, 75, 35, 0, Math.PI, false);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(60, 65, 5, 0, Math.PI * 2, true);
                        ctx.moveTo(95, 65);
                        ctx.arc(90, 65, 5, 0, Math.PI * 2, true);
                        ctx.stroke();
                        break;
                    case "KeyH":
                        ctx.moveTo(75, 40);
                        ctx.bezierCurveTo(75, 37, 70, 25, 50, 25);
                        ctx.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5);
                        ctx.bezierCurveTo(20, 80, 40, 102, 75, 120);
                        ctx.bezierCurveTo(110, 102, 130, 80, 130, 62.5);
                        ctx.bezierCurveTo(130, 62.5, 130, 25, 100, 25);
                        ctx.bezierCurveTo(85, 25, 75, 37, 75, 40);
                        ctx.stroke();
                        break;
                    case "KeyU":
                    case "KeyL":
                        const char = alphabet[Math.floor(Math.random() * alphabet.length)];
                        ctx.font = "100px Arial";
                        ctx.fillText(finalCode === "KeyL" ? char.toLowerCase() : char, 0, 0);
                        break;
                    case "KeyN":
                        ctx.font = "100px Arial";
                        ctx.fillText(Math.floor(Math.random() * 10), 0, 0);
                        break;
                    case "KeyT":
                        const p = 5 + Math.floor(Math.random() * 3);
                        for (let i = 0; i < p * 2; i++) {
                            const r = i % 2 ? 30 : 50;
                            const a = (Math.PI / p) * i;
                            ctx.lineTo(r * Math.cos(a), r * Math.sin(a));
                        }
                        ctx.closePath();
                        ctx.stroke();
                        break;
                }
                ctx.restore();
            }
        });
    </script>
</body>
</html>