<!DOCTYPE html>
<html>
<head>
    <title>Touchdraw Pad</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #app-container {
            width: 100vw;
            height: 100vh;
            background-color: black;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #myCanvas {
            display: block;
            background-color: black;
            cursor: crosshair;
            flex-grow: 1;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        button {
            padding: 10px 18px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #333;
            color: white;
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        button:hover {
            background-color: #444;
            transform: translateY(-1px);
        }

        #clearButton { background-color: #EE4E34; }
        #clearButton:hover { background-color: #d63d25; }
        
        #saveButton { background-color: #2BAE66; }
        #saveButton:hover { background-color: #218c52; }

        #fsbutton { background-color: #4831D4; }

        /* HIDE Clear and Save buttons when in Full Screen mode */
        #app-container:fullscreen #saveButton {
            display: none;
        }

        .hint {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #555;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }
        
        #app-container:fullscreen .hint {
            display: none;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div class="controls">
            <button id="saveButton">Save Drawing</button>
            <button id="clearButton">Clear Drawing</button>
            <button id="fsbutton">Full Screen</button>
        </div>

        <div class="hint">Draw with mouse/touch or press ANY key for a random shape!</div>

        <canvas id="myCanvas"></canvas>
    </div>
    
    <a id="link" style="display:none"></a>

    <script type="text/javascript">
        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        window.addEventListener("load", () => {
            const container = document.getElementById("app-container");
            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");
            
            function resize() {
                const tempImage = canvas.toDataURL();
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                const img = new Image();
                img.onload = ()=> {
                    ctx.drawImage(img,0,0);
                }
                img.src = tempImage;
            }
            window.addEventListener('resize', resize);
            resize();

            let lineWidth = 3;
            let currentTouches = [];
            let isMouseDown = false;

            const randomColor = () => {
                const colors = ["#00A3EE", "#F5D908", "#D80351", "#EE4E34", "#FF69B4", "#990011", "#4831D4", "#FEE715", "#00539C", "#2BAE66", "#BF40BF"];
                return colors[Math.floor(Math.random() * colors.length)];
            };

            const clearCanvas = () => ctx.clearRect(0, 0, canvas.width, canvas.height);

            const saveCanvas = () => {
                const link = document.getElementById("link");
                link.setAttribute("download", `Drawing-${Date.now()}.png`);
                link.setAttribute("href", canvas.toDataURL("image/png"));
                link.click();
            };

            const findCurrentTouchIndex = (id) => currentTouches.findIndex(t => t.id === id);

            // --- DRAWING LOGIC ---
            const startDrawing = (id, x, y) => {
                const color = randomColor();
                currentTouches.push({ id, pageX: x, pageY: y, color });
                ctx.beginPath();
                ctx.arc(x, y, lineWidth / 2, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            };

            const moveDrawing = (id, x, y) => {
                const idx = findCurrentTouchIndex(id);
                if (idx >= 0) {
                    const t = currentTouches[idx];
                    ctx.beginPath();
                    ctx.moveTo(t.pageX, t.pageY);
                    ctx.lineTo(x, y);
                    ctx.lineWidth = lineWidth;
                    ctx.strokeStyle = t.color;
                    ctx.lineCap = "round";
                    ctx.stroke();
                    t.pageX = x; t.pageY = y;
                }
            };

            const stopDrawing = (id) => {
                const idx = findCurrentTouchIndex(id);
                if (idx >= 0) currentTouches.splice(idx, 1);
            };

            // Event Bindings
            canvas.addEventListener("mousedown", (e) => {
                isMouseDown = true;
                startDrawing("mouse", e.clientX, e.clientY);
            });
            window.addEventListener("mousemove", (e) => {
                if (isMouseDown) moveDrawing("mouse", e.clientX, e.clientY);
            });
            window.addEventListener("mouseup", () => {
                isMouseDown = false;
                stopDrawing("mouse");
            });

            canvas.addEventListener("touchstart", (e) => {
                e.preventDefault();
                [...e.changedTouches].forEach(t => startDrawing(t.identifier, t.pageX, t.pageY));
            });
            canvas.addEventListener("touchmove", (e) => {
                e.preventDefault();
                [...e.changedTouches].forEach(t => moveDrawing(t.identifier, t.pageX, t.pageY));
            });
            canvas.addEventListener("touchend", (e) => {
                [...e.changedTouches].forEach(t => stopDrawing(t.identifier));
            });

            // Button Listeners
            document.getElementById("clearButton").addEventListener("click", function(e){
                clearCanvas();
                this.blur();
            });
            document.getElementById("saveButton").addEventListener("click", function(e){
                saveCanvas();
                this.blur();
            });
            document.getElementById("fsbutton").addEventListener("click", function(e){
                if (!document.fullscreenElement) {
                    container.requestFullscreen();
                    document.getElementById("fsbutton").innerText = "Exit Full Screen";
                } else {
                    document.exitFullscreen();
                    document.getElementById("fsbutton").innerText = "Full Screen";
                }
                this.blur();
            });

            // Keyboard Shortcuts
            document.addEventListener("keydown", (event) => {
                if (event.repeat) return;
                if (event.code === "Space" || event.code === "Enter") {
                    event.preventDefault();
                }

                if (event.code === "KeyF" && !document.fullscreenElement) {
                    container.requestFullscreen();
                } else {
                    drawRandomShape(event.code);
                }
            });

            function drawRandomShape(code) {
                const shapeButtons = ["KeyS", "KeyH", "KeyU", "KeyL", "KeyN", "KeyT"];
                const finalCode = shapeButtons.includes(code) ? code : shapeButtons[Math.floor(Math.random() * shapeButtons.length)];

                const x = Math.floor(Math.random() * (canvas.width - 100)) + 50;
                const y = Math.floor(Math.random() * (canvas.height - 100)) + 50;
                const angle = Math.random() * Math.PI * 2;
                const scale = Math.random() * 2.5 + 0.5;

                const fillColor = randomColor();
                const strokeColor = randomColor();

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.scale(scale, scale);
                
                ctx.fillStyle = fillColor;
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 4 / scale;

                ctx.beginPath();
                switch (finalCode) {
                    case "KeyS":
                        ctx.arc(75, 75, 50, 0, Math.PI * 2, true);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(110, 75);
                        ctx.arc(75, 75, 35, 0, Math.PI, false);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(60, 65, 5, 0, Math.PI * 2, true);
                        ctx.moveTo(95, 65);
                        ctx.arc(90, 65, 5, 0, Math.PI * 2, true);
                        ctx.fill();
                        break;
                    case "KeyH":
                        ctx.moveTo(75, 40);
                        ctx.bezierCurveTo(75, 37, 70, 25, 50, 25);
                        ctx.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5);
                        ctx.bezierCurveTo(20, 80, 40, 102, 75, 120);
                        ctx.bezierCurveTo(110, 102, 130, 80, 130, 62.5);
                        ctx.bezierCurveTo(130, 62.5, 130, 25, 100, 25);
                        ctx.bezierCurveTo(85, 25, 75, 37, 75, 40);
                        ctx.fill();
                        break;
                    case "KeyU":
                    case "KeyL":
                        const char = alphabet[Math.floor(Math.random() * alphabet.length)];
                        ctx.font = "100px Arial";
                        ctx.fillText(finalCode === "KeyL" ? char.toLowerCase() : char, 0, 0);
                        break;
                    case "KeyN":
                        ctx.font = "100px Arial";
                        ctx.fillText(Math.floor(Math.random() * 10), 0, 0);
                        break;
                    case "KeyT":
                        const p = 5 + Math.floor(Math.random() * 3);
                        for (let i = 0; i < p * 2; i++) {
                            const r = i % 2 ? 30 : 50;
                            const a = (Math.PI / p) * i;
                            ctx.lineTo(r * Math.cos(a), r * Math.sin(a));
                        }
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                ctx.restore();
            }
        });
    </script>
</body>
</html>